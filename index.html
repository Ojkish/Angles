<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Angles</title>
<style>
:root{
  --bg-color:#050505;
  --panel-color:#111;
  --accent-color:#f1c40f;
  --danger-color:#e74c3c;
  --text-color:#eee;
  --muted:#aaa;
}
body{
  font-family:system-ui,-apple-system, sans-serif;
  background:var(--bg-color);
  color:var(--text-color);
  margin:0;
  display:flex;
  min-height:100dvh;
  flex-direction:column;
  overflow-x:hidden;
  overflow-y:auto;
}
@media (max-width:768px){
  body{flex-direction:column;overflow-y:auto;}
  .sidebar{width:100% !important;border-right:none !important;order:2;padding:10px !important;}
  .view{height:45vh;order:1;flex-shrink:0;}
  .results-container{order:0;width:100%;}
}
.sidebar{
  width:300px;
  background:var(--panel-color);
  padding:12px;
  border-right:1px solid #333;
  display:flex;
  flex-direction:column;
  gap:8px;
  box-sizing:border-box;
}
.results-container{display:flex;flex-direction:column;}
.view{flex-grow:1;background:#000;position:relative;min-height:250px;}
canvas{width:100%;height:100%;display:block;}
.input-group{
  background:#1a1a1a;padding:8px 12px;border-radius:8px;border:1px solid #222;
}
label{
  display:block;font-size:0.7em;color:#888;margin-bottom:4px;text-transform:uppercase;font-weight:bold;letter-spacing:0.5px;
}
.flex-input{display:flex;gap:10px;align-items:center;}
input[type="range"]{flex-grow:1;accent-color:var(--accent-color);cursor:pointer;}
input[type="number"]{
  width:70px;background:#222;border:1px solid #444;color:#fff;padding:4px;border-radius:4px;font-weight:bold;font-size:0.9em;
}

/* Résultats : mise en valeur de la largeur, tilt moins proéminent */
.results{
  background:var(--panel-color);
  color:var(--text-color);
  padding:12px 14px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.04);
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:nowrap;
}

/* Gros bloc gauche */
.res-left{
  display:flex;
  flex-direction:column;
  gap:6px;
}

/* Largeur au sol : mise en évidence */
.res-label{ font-size:0.8rem; color:var(--muted); font-weight:700; text-transform:uppercase; letter-spacing:0.6px; }
.res-diam { font-size:1.8rem; font-weight:900; color:var(--accent-color); font-family:system-ui, -apple-system, sans-serif; }

/* Tilt plus discret */
.res-tilt { font-size:0.9rem; color:var(--muted); font-weight:600; }

/* Boutons : à droite, même taille */
.res-actions { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
.res-actions .btn {
  background: transparent;
  color: var(--text-color);
  border: 1px solid rgba(255,255,255,0.06);
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-weight:700;
  min-width:130px;       /* même largeur */
  text-align:center;
}
.res-actions .btn:hover { background: rgba(255,255,255,0.02); }

.results.infinite .res-diam { color: var(--danger-color); }

@media (max-width:420px){
  .res-diam { font-size:1.4rem; }
  input[type="number"]{ width:60px; }
  .res-actions .btn { min-width:100px; padding:6px 8px; font-size:0.85rem; }
}
</style>
</head>
<body>

<div class="results-container" id="topResults">
  <div id="resPanel" class="results" aria-live="polite">
    <div class="res-left">
      <div class="res-label">Largeur au sol</div>
      <div id="resDiam" class="res-diam">--</div>
      <div id="resTilt" class="res-tilt">--</div>
    </div>

    <div class="res-actions" aria-hidden="false">
      <button id="recenterProjBtn" class="btn" title="Recentrer le projecteur en position horizontale (tilt = 0)">Recentrer</button>
      <button id="decalZeroBtn" class="btn" title="Remettre le décalage à zéro (d = 0)">Décalage zéro</button>
    </div>
  </div>
</div>

<div class="sidebar">
  <div id="sidebarTarget"></div>

  <div class="input-group">
    <label>Ouverture α (°)</label>
    <div class="flex-input">
      <input type="range" id="alphaRange" min="1" max="120" value="40">
      <input type="number" step="any" id="alphaNum" value="40">
    </div>
  </div>

  <div class="input-group">
    <label>Hauteur h (m)</label>
    <div class="flex-input">
      <input type="range" id="hRange" min="1" max="20" step="0.1" value="7">
      <input type="number" step="any" id="hNum" value="7">
    </div>
  </div>

  <div class="input-group">
    <label>Décalage (d) (m)</label>
    <div class="flex-input">
      <input type="range" id="decalRange" min="-30" max="30" step="0.01" value="0">
      <input type="number" step="any" id="decalNum" value="0">
    </div>
  </div>
</div>

<div class="view">
  <canvas id="canvas" aria-hidden="true"></canvas>
</div>

<script>
/* === DOM references === */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const resPanel = document.getElementById('resPanel');
const topResults = document.getElementById('topResults');
const sidebarTarget = document.getElementById('sidebarTarget');

const alphaRange = document.getElementById('alphaRange');
const hRange = document.getElementById('hRange');
const decalRange = document.getElementById('decalRange');

const alphaNum = document.getElementById('alphaNum');
const hNum = document.getElementById('hNum');
const decalNum = document.getElementById('decalNum');

const resDiam = document.getElementById('resDiam');
const resTilt = document.getElementById('resTilt');
const recenterProjBtn = document.getElementById('recenterProjBtn');
const decalZeroBtn = document.getElementById('decalZeroBtn');

/* === last valid numeric values used for drawing (robust while typing) === */
const lastValid = {
  alpha: toNumberFromInputString(alphaNum.value) || 40,
  h: toNumberFromInputString(hNum.value) || 7,
  decal: toNumberFromInputString(decalNum.value) || 0
};

/* === animation control === */
let currentAnim = null; // holds { cancel: ()=>void } or null
let autoCenter = true;

/* === responsive placement === */
function adjustLayout(){
  if (window.innerWidth <= 768){
    if (resPanel.parentElement !== topResults) topResults.appendChild(resPanel);
  } else {
    if (resPanel.parentElement !== sidebarTarget) sidebarTarget.appendChild(resPanel);
  }
  update();
}
window.addEventListener('resize', adjustLayout);

/* === helpers === */
function toNumberFromInputString(str){
  if (typeof str !== 'string' && typeof str !== 'number') return NaN;
  const s = (''+str).replace(',', '.').trim();
  const n = parseFloat(s);
  return isFinite(n) ? n : NaN;
}
function isWithinRange(val, rangeEl){
  const min = parseFloat(rangeEl.min);
  const max = parseFloat(rangeEl.max);
  if (isNaN(min) || isNaN(max)) return false;
  return val >= min && val <= max;
}

/* === cancel animation helper === */
function cancelCurrentAnimation(){
  if (currentAnim && typeof currentAnim.cancel === 'function'){
    currentAnim.cancel();
  }
  currentAnim = null;
}

/* === Range -> Number sync (range enforces limits) === */
/* cancel animation if user manipulates controls directly */
alphaRange.addEventListener('input', () => {
  cancelCurrentAnimation();
  alphaNum.value = alphaRange.value;
  lastValid.alpha = parseFloat(alphaRange.value);

  if(autoCenter){
    const aRad = lastValid.alpha * Math.PI / 180;
    const newD = lastValid.h * Math.tan(-aRad/2);
    lastValid.decal = newD;
    decalNum.value = newD;
    if (isWithinRange(newD, decalRange)) decalRange.value = newD;
  }

  update();
});
hRange.addEventListener('input', () => {
  cancelCurrentAnimation();
  hNum.value = hRange.value;
  lastValid.h = parseFloat(hRange.value);

  if(autoCenter){
    const aRad = lastValid.alpha * Math.PI / 180;
    const newD = lastValid.h * Math.tan(-aRad/2);
    lastValid.decal = newD;
    decalNum.value = newD;
    if (isWithinRange(newD, decalRange)) decalRange.value = newD;
  }

  update();
});
decalRange.addEventListener('input', () => {
  autoCenter = false; // <-- ajouté
  cancelCurrentAnimation();
  decalNum.value = decalRange.value;
  lastValid.decal = parseFloat(decalRange.value);
  update();
});

/* === Number inputs: accept any numeric value; only sync slider if value in slider's range === */
function bindNumberInput(numEl, rangeEl, keyName){
  numEl.addEventListener('input', (e) => {
    // user typing -> cancel animation
    cancelCurrentAnimation();

     if(keyName === 'decal'){
    autoCenter = false; // <-- ajouté
  }

    const raw = e.target.value;
    const n = toNumberFromInputString(raw);
    if (!isNaN(n)){
      lastValid[keyName] = n;
      if (rangeEl && isWithinRange(n, rangeEl)){
        rangeEl.value = n;
      }
    }
    update();
  });

  numEl.addEventListener('focus', function(){
    try { this.select(); } catch (err) {}
    setTimeout(()=>{ this.scrollIntoView({behavior:'smooth', block:'center'}); }, 300);
  });

  numEl.addEventListener('blur', (e) => {
    const raw = e.target.value;
    if (raw === '') return;
    const n = toNumberFromInputString(raw);
    if (!isNaN(n)){
      e.target.value = '' + n;
    }
  });
}

bindNumberInput(alphaNum, alphaRange, 'alpha');
bindNumberInput(hNum, hRange, 'h');
bindNumberInput(decalNum, decalRange, 'decal');

/* === Initial decal from defaults (keeps UI stable for old users) === */
(function initializeDecalFromDefaults(){
  const a0 = toNumberFromInputString(alphaNum.value) || lastValid.alpha;
  const h0 = toNumberFromInputString(hNum.value) || lastValid.h;
  const t0 = 0;
  const aRad0 = a0 * Math.PI / 180;
  const angleGauche0 = t0 * Math.PI / 180 - aRad0/2;
  const d0 = h0 * Math.tan(angleGauche0);
  lastValid.decal = isFinite(d0) ? d0 : 0;
  decalNum.value = '' + lastValid.decal;
  if (isWithinRange(lastValid.decal, decalRange)){
    decalRange.value = lastValid.decal;
  }
})();

/* === animation helper: interpolate lastValid.decal -> target over duration (ms) === */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function animateDecalTo(target, duration = 250){
  cancelCurrentAnimation();
  const startVal = Number(lastValid.decal);
  const startTime = performance.now();
  let rafId = null;
  let cancelled = false;

  currentAnim = {
    cancel: () => {
      cancelled = true;
      if (rafId) cancelAnimationFrame(rafId);
      currentAnim = null;
    }
  };

  function step(now){
    if (cancelled) return;
    const p = Math.max(0, Math.min(1, (now - startTime) / duration));
    const eased = easeOutCubic(p);
    const cur = startVal + (target - startVal) * eased;
    lastValid.decal = cur;
    // update visible number field (do not force formatting too early)
    decalNum.value = ('' + (Math.round(cur * 1000000) / 1000000)); // keep reasonable precision
    if (isWithinRange(cur, decalRange)) decalRange.value = cur;
    update();
    if (p < 1){
      rafId = requestAnimationFrame(step);
    } else {
      // finalize exact target
      lastValid.decal = target;
      decalNum.value = '' + target;
      if (isWithinRange(target, decalRange)) decalRange.value = target;
      currentAnim = null;
      update();
    }
  }

  rafId = requestAnimationFrame(step);
}

/* === Recentrer le projecteur (tilt = 0) === */
recenterProjBtn.addEventListener('click', () => {
      autoCenter = true;

  // compute d that makes tilt = 0
  const a = Number(lastValid.alpha);
  const h = Number(lastValid.h);
  const aRad = isFinite(a) ? a * Math.PI / 180 : 0;
  const d0 = h * Math.tan(-aRad/2);          // = -h * tan(aRad/2)
  const dVal = isFinite(d0) ? d0 : 0;
  animateDecalTo(dVal, 250);
});

/* === Décalage zéro (d = 0) === */
decalZeroBtn.addEventListener('click', () => {

  // On met la valeur du slider
  decalRange.value = 0;

  // On déclenche exactement le même comportement
  decalRange.dispatchEvent(new Event('input', { bubbles: true }));

});
/* === Core calculation & drawing ===
   User controls decal 'd'. From d, a and h we compute:
     angleGauche = atan2(d, h)
     angleDroit = angleGauche + aRad
     tilt tRad = angleGauche + aRad/2
*/
function update(){
  const a = Number(lastValid.alpha);
  const h = Number(lastValid.h);
  const d = Number(lastValid.decal);

  const aRad = (isFinite(a) ? a * Math.PI / 180 : 0);
  const hNumVal = (isFinite(h) ? h : 0);
  const dNumVal = (isFinite(d) ? d : 0);

  const angleGauche = Math.atan2(dNumVal, hNumVal);
  const angleDroit = angleGauche + aRad;
  const tRad = angleGauche + aRad/2;
  const tDeg = (tRad * 180 / Math.PI);

  const EPS = 1e-12;
  const isInfinite = (angleGauche <= -Math.PI/2 + EPS) || (angleDroit >= Math.PI/2 - EPS);

  const x1 = -dNumVal;
  let x2;
  if (angleDroit >= Math.PI/2 - EPS){
    x2 = -5000;
  } else {
    x2 = -hNumVal * Math.tan(angleDroit);
  }

  // affichages : largeur très visible, tilt discret (1 décimale)
  resDiam.innerText = isInfinite ? "∞" : Math.abs(x2 - x1).toFixed(2) + " m";
  resTilt.innerText = isFinite(tDeg) ? (tDeg.toFixed(1) + "°") : "NaN";

  if (isInfinite) resPanel.classList.add('infinite');
  else resPanel.classList.remove('infinite');

  draw(hNumVal, tRad, x1, x2, isInfinite);
}

/* === draw (visual behavior) === */
function draw(h, tRad, x1, x2, isInfinite){
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  const scale = Math.min(canvas.width / (Math.max(h, 0) + 5), canvas.height / 20);
  const startX = 60;
  const centerY = canvas.height / 2;
  const groundX = startX + (h * scale);

  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle = "#444"; ctx.lineWidth = 1;
  ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(groundX,0); ctx.lineTo(groundX,canvas.height); ctx.stroke();

  ctx.strokeStyle = "rgba(255,255,255,0.2)";
  ctx.setLineDash([5,5]);
  ctx.beginPath(); ctx.moveTo(startX, centerY); ctx.lineTo(groundX, centerY); ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = isInfinite ? "rgba(231,76,60,0.45)" : "rgba(241,196,15,0.35)";
  ctx.beginPath();
  ctx.moveTo(startX, centerY);
  ctx.lineTo(groundX, centerY + (x1 * scale));
  ctx.lineTo(groundX, centerY + (x2 * scale));
  ctx.closePath();
  ctx.fill();

  ctx.save();
  ctx.translate(startX, centerY);
  ctx.rotate(-tRad);
  ctx.fillStyle = "#333"; ctx.fillRect(-35, -12, 35, 24);
  ctx.fillStyle = isInfinite ? "#e74c3c" : "#f1c40f";
  ctx.fillRect(-2, -12, 4, 24);
  ctx.restore();

  ctx.fillStyle = "#888";
  ctx.font = "bold 13px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("h = " + h + "m", (startX + groundX)/2, centerY - 15);
}

/* === kickoff === */
adjustLayout();
</script>
</body>
</html>
